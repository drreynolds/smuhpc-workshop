:tocdepth: 2


.. _session5:

Session 5: Advanced Programming
========================================================

*Instructor: Dan Reynolds*

*Assistants: Amit Kumar, Merlin Wilkerson, Doug Tucker*




Getting started
------------------

We will perform this session of the workshop on the ``smuhpc3`` login
node, so log in there to begin.

In this session, we will use examples in either C, C++ or Fortran90.
Choose your preferred language of the three and download the files to
be used in this session by either clicking one of the following three
links: :download:`C version <code/session5_c.tgz>`, :download:`C++
version <code/session5_cxx.tgz>`, :download:`F90 version
<code/session5_f90.tgz>`, or by copying the relevant files on SMU HPC
with one of the following 3 commands: 

.. code-block:: bash

   $ cp ~dreynolds/SMUHPC_tutorial/session5_c.tgz .
   $ cp ~dreynolds/SMUHPC_tutorial/session5_cxx.tgz .
   $ cp ~dreynolds/SMUHPC_tutorial/session5_f90.tgz .

Unpack your tarball and enter the resulting directory.


.. index:: profiling

Profiling and performance analysis
------------------------------------------------------


Enabling and Generating Profiling Information
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

In this session, we will be using the GNU compiler suite
(``gcc``, ``g++``, ``gfortran``).  These compilers are installed on
SMU HPC and at every supercomputer center I've ever used.  It is a free
suite of compilers for C, C++ and Fortran code, and is available for
Windows, OS X and of course Linux. 

.. index:: 
   pair: profiling; -p

In these compilers (and many others), you can enable profiling information
through adding in the ``-p`` compiler flag.  Add this compiler flag to
the commands in the ``Makefile`` for the target ``driver1.exe`` [Hint: put
it before the ``-o``].

.. index:: 
   pair: profiling; gmon.out

Profiling information is generated by running the executable once to
completion.  Run the driver as usual.  Write down the total runtime
required for the program (you will use this information later
on). When the program has finished, you should see a new file
in the directory called ``gmon.out``. This contains the relevant
profiling data, and was written during the execution of the code. 

.. index:: 
   pair: profiling; gprof

Examine the profiling information by using the program ``gprof``. You
use this by calling ``gprof``, followed by the executable name. It
will automatically look in the ``gmon.out`` file in that directory for
the profiling data that relates to the executable. Run the command 

.. code-block:: bash

   $ gprof driver1.exe

When you run ``gprof``, it outputs all of the profiling information to
the screen.  To enable easier examination of these results, you should
instead send this data to a file. You can redirect this information to
the file ``profiling_data.txt`` with the command 

.. code-block:: bash

   $ gprof driver1.exe > profiling_data.txt

You will then have the readable file ``profiling_data.txt`` with the
relevant profiling information. 



Identifying Bottleneck Routines
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Read through the first table of profiling information in this file.
The first column of this table shows the percentage of time spent in
each function called by the driver. Identify which one takes the vast
majority of the time.  This bottleneck should be the first routine that
you investigate for optimization. 


Optimizing Your Code
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. index:: grep

Look through the routine identified from the previous step -- the
function may be contained in a file with a different name, so you can
use ``grep`` to find which file contains the routine: 

.. code-block:: bash

   $ grep -i routine_name *

where ``routine_name`` is the function that you identified from
the previous step.  Save a copy of this file using the ``cp`` command, e.g.

.. code-block:: bash

   $ cp file.cpp file_old.cpp

where ``file`` is the file that you have identified as containing the
bottleneck routine (use the appropriate extension for your coding
language). We will use this original file again later in the session. 

Determine what, if anything, can be optimized in this routine.  Is
there a simpler way that the arithmetic could be accomplished?  Is it
accessing memory in an optimal manner?  Is it doing any redundant
computations? 

Find what you can fix, so long as you do not change the
mathematical result.  Delete and re-compile the executable,

.. code-block:: bash

   $ rm driver1.exe; make driver1.exe

re-run the executable

.. code-block:: bash

   $ ./driver1.exe

Re-examine the results using ``gprof``, and repeat the optimization
process until you are certain that the code has been sufficiently
optimized.  You should be able to achieve a significant performance
improvement (at least 40% faster than the original).

Write down the total runtime required for your hand-optimized program.
Copy your updated code to the file ``file_new.cpp`` (again, use the
appropriate extension for your coding language).




.. index:: compiler optimizations

Automatic Compiler Optimizations
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The compiler may also attempt to optimize the code itself. Try
rebuilding the original (non-optimized) code with the compiler flag
``-O2`` (capital 'o' for "Optimize", followed by a '2' to denote the
optimization level): 

1. Replace the current flag ``-O0`` in your ``Makefile`` with the flag
   ``-O2``. 

2. Copy the original file back, e.g. 
  
   .. code-block:: bash

      $ cp file_old.cpp file.cpp

3. Delete the old executable,

   .. code-block:: bash

      $ rm driver1.exe

4. Re-compile ``driver1.exe``,

   .. code-block:: bash

      $ make driver1.exe

5. Re-run ``driver1.exe``,

   .. code-block:: bash

      $ ./driver1.exe

Does this result in faster code than the original?  Is it faster than
your hand-optimized code?  Write down the total run-time required for
this test.

Repeat the above steps, but this time using **both** the ``-O2``
compiler flag **and** your hand-optimized code in ``file_new.cpp``.
Determine you can see how well the code runs when you provide a
hand-optimized code to then allow the compiler to optimize as well.
How does this perform in comparison to the other three runs? 




.. index:: debugging

Debugging and debuggers
------------------------------------------------------

Enabling Debugging Information
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. index:: 
   pair: debugging; -g

In most compilers (including GNU and PGI), you can enable debugging
information through adding the ``-g`` compiler flag. Add this flag to
the compilation commands in the ``Makefile`` for the target
``driver2.exe``, and then compile the executable,

.. code-block:: bash

   $ make driver2.exe

.. index:: 
   pair: debugging; segmentation fault
   pair: debugging; bus error

Run the new executable.  It should die with an error message about a
segmentation violation (segmentation fault) or bus error, depending on
the compiler/OS, e.g.

.. code-block:: bash

   $ ./driver2.exe
   Segmentation fault

There are many ways to track down this kind of error (e.g. print
statements, staring, randomly changing things to see what happens).
In this session we will use the most efficient debugging approach,
that of using a tool to track down the bug for us.

.. index:: 
   pair: debugging; gdb

The tool we will use is the GNU debugger, which can be accessed
through running the faulty executable program from within the
debugging program itself.  On ``smuhpc3``, you must first load the
``gcc`` module before accessing ``gdb`` (on the other login nodes this
step is not required):

.. code-block:: bash
 
   $ module load gcc

Load the executable into ``gdb`` with the command 

.. code-block:: bash
 
   $ gdb driver2.exe

At the ``gdb`` prompt, type ``run`` to start the executable.  It will
automatically stop at the line where the segmentation fault occurs.

In another terminal window, you can type ``man gdb`` to learn more
about how to use the debugger (or you can `click here to view the gdb
man page on the web <http://linux.die.net/man/1/gdb>`_.  

* Perhaps the most valuable gdb command is ``print`` that may be used
  to see the internal value of a specified variable, e.g.

  .. code-block:: bash

     (gdb) print i

  will print out the current value of the iteration variable ``i``). 

* The ``help`` command inside of ``gdb`` may be used to find out more
  information on how to use the program itself.

* The ``quit`` command inside of ``gdb`` will exit the debugger and
  return you to the command line.



Fixing the Bug
^^^^^^^^^^^^^^^^

C users: 
  Open both the files ``driver2.c`` and ``tridiag_matvec.c``,
  and see if you can find/fix the problem by using ``gdb`` and ``print``
  statements as appropriate. 

C++ users: 
  Open both the files ``driver2.cpp`` and
  ``tridiag_matvec.cpp``, and see if you can find/fix the problem by
  using ``gdb`` and ``print`` statements as appropriate.  

F90 users: 
  Open both the files ``driver2.f90`` and
  ``tridiag_matvec.f90``, and see if you can find/fix the problem by
  using ``gdb`` and ``print`` statements as appropriate.

.. index:: 
   pair: debugging; segmentation fault
   pair: debugging; bus error

A word of warning, the location of the segmentation fault or bus error
is not always where the problem is located.  Segmentation faults
generally occur due to an attempt within the program to read to or
write from an illegal memory location, i.e. a memory location that is
not a part of a currently-available variable.  Examples of bugs that
can cause a seg-fault are iterating outside of the bounds of an array,
or a mismatch between the arguments that a program uses to call a
function and the arguments that the function expects to receive. 

Upon finding and fixing the bug causing the segmentation fault, the
correctly-executing program should write the following line: 

.. code-block:: text

   2-norm of product = 1.414213562373E+00

(or something within roundoff error of this result), and it should
write the file ``r.txt`` that contains the result of the matrix-vector 
product. This output vector should contain all 0's except for the
first and last entries, which should be 1.



.. index:: debugging; advanced debuggers

More advanced debuggers
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

There are many freely-available Linux debugging utilites in addition
to `gdb <https://www.gnu.org/software/gdb/>`_.  Most of these are
graphical (i.e. point-and-click), and in fact use ``gdb`` under the
hood.  Some of the more popular of these debuggers include:  `ddd
<https://www.gnu.org/software/ddd/>`_, `nemiver
<http://projects.gnome.org/nemiver/>`_, `eclipse
<http://www.eclipse.org/eclipse/debug/>`_, `zerobugs
<https://zerobugs.codeplex.com/>`_, `edb
<http://www.woodmann.com/collaborative/tools/index.php/EDB_Linux_Debugger>`_.
However, of this set the SMU HPC cluster currently only has ``gdb``
installed (ask your system administrators for others you want/need). 

Additionally, there are some highly advanced non-free
Linux debugging utilities available (all typically graphical),
including `TotalView
<http://www.roguewave.com/products/totalview.aspx>`_, `DDT
<http://www.allinea.com/products/ddt/>`_, `idb
<http://software.intel.com/en-us/articles/idb-linux>`_ (only works
with the Intel compilers), and PGI's `pgdebug
<http://www.pgroup.com/products/pgdbg.htm>`_ (graphical) and `pgdbg`
(text version).  Of these, the SMU HPC cluster has both ``pgdebug`` and
``pgdbg``.  

The usage of most of the above debuggers is similar to ``gdb``, except
that in graphical debuggers it can be easier to view the
data/instruction stack.  The primary benefit of the non-free debuggers
is their support for debugging parallel jobs that use OpenMP,
MPI, or hybrid MPI/OpenMP computing approaches (see session 9).  In
fact, some of these professional tools can even be used to debug code
running on GPU accelerators.

