Advanced Programming (Wed. AM)
========================================================


Download the files to be used in this session with the command

.. code-block:: bash

   % wget http://dreynolds.math.smu.edu/Math6370/Lab4_files/lab4.tgz




Profiling and performance analysis
------------------------------------------------------


I. Enabling and Generating Profiling Information

We will be using the g++ compiler for this lab, to gain experience with it as well. g++ is installed on all of the Math department linux machines, on SMUHPC, and at nearly every supercomputer center. It is a free compiler for C++ code, and is available for Windows, OS X and of course Linux.

In the g++ compiler (and many others, including icc), you enable profiling information through adding in the -p compiler flag. Add this compiler flag to the commands in the Makefile for the target driver1.exe.   [Hint: put it before the -o]

Profiling information is generated by running the executable once. Run the driver as usual. Write down the total runtime required for the program (you will use this information later on). When the program has finished, you should see an additional file in the directory called gmon.out. This contains the relevant profiling data.

Examine the profiling information by using the program gprof. You use this by calling gprof, followed by the executable name. It will automatically look in the gmon.out file for the profiling data that relates to the executable. Run the command

gprof driver1.exe
When you run gprof, it outputs all of the profiling information to the screen. To enable easier examination of these results, you should instead send this data to a file. You can write this information to the file profiling_data.txt with the command
gprof driver1.exe > profiling_data.txt
You will then have the readable file profiling_data.txt with the relevant profiling information.


II. Identifying Bottleneck Routines

Read through the first table of profiling information. The first column of this table shows the percentage of time spent in each function called by the driver. Identify which one takes the vast majority of the time. This bottleneck should be the first routine that you investigate for optimization.

III. Optimizing C++ Code

Look through the routine identified from step II -- the function may be contained in a file with a different name, use grep to find which file contains the routine:

grep -i routine_name *.cpp
where routine_name is the function that you identified from step II. Save a copy of this file using the cp command [cp file.cpp file_old.cpp], where file is the file that you have identified as containing the bottleneck routine. We will use this original file again later in the lab.
Determine what, if anything, can be optimized in this routine. Is there a simpler way that the arithmetic could be accomplished? Is it accessing memory in an optimal manner? Is it doing any redundant computations? Find what you can fix, so long as you do not change the mathematical result. Delete and re-compile the executable [rm driver1.exe and then make driver1.exe], re-run the executable [./driver1.exe], re-examine the results [use gprof, etc.]. Continue this process until you have achieved a significant performance improvement (about 30% faster than as before).

Write down the total runtime required for your hand-optimized program. Copy your updated code to the file file_new.cpp.

IV. Automatic Compiler Optimizations

The compiler may also attempt to optimize the code itself. Try the original (non-optimized) code with the compiler flag -O2 (capital 'o' for "Optimize", followed by a '2' to denote the optimization level):

Replace the current flag -O0 in your Makefile with the flag -O2.
Copy the original file back [cp file_old.cpp file.cpp].
Delete the old executable.
Re-compile driver1.exe.
Re-run driver1.exe.
Does this result in faster code than the original? Is it faster than your hand-optimized code? Write down the total run-time required for this test.
Try the same -O2 compiler flag on your hand-optimized code, so that you can see how well the code runs when you provide a hand-optimized code to then allow the compiler to optimize as well. How does this perform in comparison to the other three runs?

Write a short summary of your results for the four cases -O0
versus -O2 and original versus hand-optimized, to a new file
optimization_results.txt [run emacs optimization_results.txt & and
write your results in the new file that was created].




Debugging and debuggers
------------------------------------------------------

I. Enabling Debugging Information

In the g++ compiler (and others), you enable debugging information through adding the -g compiler flag. Add this flag to the compilation commands in the Makefile for the target driver2.exe, and then compile the executable [make driver2.exe].

Run the new executable. It should die with an error message about a segmentation violation (segmentation fault) or bus error, depending on the compiler/OS.

The GNU debugger is used through running the faulty executable program from within the debugger. Run the command

gdb driver2.exe
At the gdb prompt, type run to start the executable. It will automatically stop at the line where the segmentation fault occurs. In another terminal window, you can type man gdb to learn more about how to use the debugger. The print command may be used to see the internal value of a specified variable [for example, print i will print out the current value of the iteration variable]. The help command inside of gdb may be used to find out more information on how to use the program.
The quit command inside of gdb will exit the debugger and return you to the command line.

II. Fixing the Bug

Open both the files driver2.cpp and tridiag_matvec.cpp in emacs, and see if you can find the problem by using gdb and print statements as appropriate.

The location of the segmentation fault or bus error is not always where the problem is located. Segmentation faults generally occur due to an attempt to read to or write from an illegal memory location, i.e. a memory location that is not a part of a currently available variable. Examples of bugs that can cause a seg-fault are iterating outside of the bounds of an array, or a mismatch between the arguments that a program uses to call a function and the arguments that the function expects to receive.

Upon finding and fixing the bug causing the segmentation fault, the correctly-executing program should write the following line:

2-norm of product = 1.414213562373E+00
(or something within roundoff error of this result), and it should
write the file r.txt that contains the result of the matrix-vector
product. This output vector should contain all 0's except for the
first and last entries, which should be 1.




