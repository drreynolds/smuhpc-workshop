Session 5: Advanced Programming
========================================================

*Instructor: Dan Reynolds*

*Assistants: Amit Kumar, Merlin Wilkerson, Doug Tucker*


Getting started
------------------

In this session, we will use examples in either C, C++ or Fortran90.
Choose your preferred language of the three and download the files to
be used in this session by either clicking one of the following three
links: :download:`C version <code/session5_c.tgz>`, :download:`C++
version <code/session5_cxx.tgz>`, :download:`F90 version
<code/session5_f90.tgz>`, or by copying the relevant files on SMUHPC
with one of the following 3 commands: 

.. code-block:: bash

   % cp ~dreynolds/SMUHPC_tutorial/session5_c.tgz .
   % cp ~dreynolds/SMUHPC_tutorial/session5_cxx.tgz .
   % cp ~dreynolds/SMUHPC_tutorial/session5_f90.tgz .


Profiling and performance analysis
------------------------------------------------------


Enabling and Generating Profiling Information
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

In this session, we will be using the GNU compiler suite
(``gcc``, ``g++``, ``gfortran``).  These compilers are installed on
SMUHPC and at every supercomputer center I've ever used.  It is a free
suite of compilers for C, C++ and Fortran code, and is available for
Windows, OS X and of course Linux. 

In these compilers (and many others), you can enable profiling information
through adding in the ``-p`` compiler flag.  Add this compiler flag to
the commands in the ``Makefile`` for the target driver1.exe  [Hint: put
it before the ``-o``].

Profiling information is generated by running the executable once to
completion.  Run the driver as usual.  Write down the total runtime
required for the program (you will use this information later
on). When the program has finished, you should see a new file
in the directory called ``gmon.out``. This contains the relevant
profiling data, and was written during the execution of the code. 

Examine the profiling information by using the program ``gprof``. You
use this by calling ``gprof``, followed by the executable name. It
will automatically look in the ``gmon.out`` file in that directory for
the profiling data that relates to the executable. Run the command 

.. code-block:: bash

   % gprof driver1.exe

When you run ``gprof``, it outputs all of the profiling information to
the screen.  To enable easier examination of these results, you should
instead send this data to a file. You can redirect this information to
the file ``profiling_data.txt`` with the command 

.. code-block:: bash

   % gprof driver1.exe > profiling_data.txt

You will then have the readable file ``profiling_data.txt`` with the
relevant profiling information. 



Identifying Bottleneck Routines
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Read through the first table of profiling information in this file.
The first column of this table shows the percentage of time spent in
each function called by the driver. Identify which one takes the vast
majority of the time.  This bottleneck should be the first routine that
you investigate for optimization. 


Optimizing Your Code
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Look through the routine identified from the previous step -- the
function may be contained in a file with a different name, so you can
use ``grep`` to find which file contains the routine: 

.. code-block:: bash

   % grep -i routine_name *

where ``routine_name`` is the function that you identified from
the previous step.  Save a copy of this file using the ``cp`` command
(e.g. ``cp file.cpp file_old.cpp``), where ``file`` is the file that
you have identified as containing the bottleneck routine. We will use
this original file again later in the session. 

Determine what, if anything, can be optimized in this routine.  Is
there a simpler way that the arithmetic could be accomplished?  Is it
accessing memory in an optimal manner?  Is it doing any redundant
computations? 

Find what you can fix, so long as you do not change the
mathematical result.  Delete and re-compile the executable (e.g. 
``rm driver1.exe; make driver1.exe``), re-run the executable
(``./driver1.exe``), re-examine the results (use ``gprof``,
etc.).  Continue this process until you have achieved a significant
performance improvement (at least 30% faster than as before). 

Write down the total runtime required for your hand-optimized program.
Copy your updated code to the file ``file_new.cpp``.


Automatic Compiler Optimizations
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The compiler may also attempt to optimize the code itself. Try
rebuilding the original (non-optimized) code with the compiler flag
``-O2`` (capital 'o' for "Optimize", followed by a '2' to denote the
optimization level): 

1. Replace the current flag ``-O0`` in your ``Makefile`` with the flag ``-O2``.

2. Copy the original file back (e.g. ``cp file_old.cpp file.cpp``).

3. Delete the old executable.

4. Re-compile ``driver1.exe``.

5. Re-run ``driver1.exe``.

Does this result in faster code than the original?  Is it faster than
your hand-optimized code?  Write down the total run-time required for
this test.

Try the same ``-O2`` compiler flag on your hand-optimized code, so
that you can see how well the code runs when you provide a
hand-optimized code to then allow the compiler to optimize as well.
How does this perform in comparison to the other three runs? 


Optimization with the PGI compiler
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**FILL THIS IN**



Debugging and debuggers
------------------------------------------------------

Enabling Debugging Information
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

In most compilers (include GNU and PGI), you can enable debugging
information through adding the ``-g`` compiler flag. Add this flag to
the compilation commands in the ``Makefile`` for the target
``driver2.exe``, and then compile the executable (``make
driver2.exe``). 

Run the new executable.  It should die with an error message about a
segmentation violation (segmentation fault) or bus error, depending on
the compiler/OS.  There are many ways to track down this kind of
error (print statements, staring, randomly changing things to see what
happens), in this session we will use the most optimal approach, that
of using a tool to track down the bug for us.

This tool is the GNU debugger, which can be used through running the
faulty executable program from within the debugger itself. Run the
command 

.. code-block:: bash
 
   % gdb driver2.exe

At the ``gdb`` prompt, type ``run`` to start the executable. It will
automatically stop at the line where the segmentation fault occurs.
In another terminal window, you can type ``man gdb`` to learn more
about how to use the debugger.  Perhaps the most valuable command is
``print`` that may be used to see the internal value of a specified
variable (e.g. ``print i`` will print out the current value of the
iteration variable ``i``). The ``help`` command inside of ``gdb`` may
be used to find out more information on how to use the program. 

The ``quit`` command inside of ``gdb`` will exit the debugger and
return you to the command line. 


Fixing the Bug
^^^^^^^^^^^^^^^^

C users: open both the files driver2.c and tridiag_matvec.c, and see
if you can find/fix the problem by using ``gdb`` and ``print``
statements as appropriate. 

C++ users: Open both the files driver2.cpp and tridiag_matvec.cpp, and
see if you can find/fix the problem by using ``gdb`` and ``print``
statements as appropriate.  

F90 users: Open both the files driver2.f90 and tridiag_matvec.f90, and
see if you can find/fix the problem by using ``gdb`` and ``print``
statements as appropriate.

A word of warning, the location of the segmentation fault or bus error
is not always where the problem is located.  Segmentation faults
generally occur due to an attempt within the program to read to or
write from an illegal memory location, i.e. a memory location that is
not a part of a currently-available variable.  Examples of bugs that
can cause a seg-fault are iterating outside of the bounds of an array,
or a mismatch between the arguments that a program uses to call a
function and the arguments that the function expects to receive. 

Upon finding and fixing the bug causing the segmentation fault, the
correctly-executing program should write the following line: 

.. code-block:: bash

   2-norm of product = 1.414213562373E+00

(or something within roundoff error of this result), and it should
write the file ``r.txt`` that contains the result of the matrix-vector 
product. This output vector should contain all 0's except for the
first and last entries, which should be 1.



Debugging with the PGI compiler
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**FILL THIS IN**
